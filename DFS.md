### DFS Template

#### 1 路径问题

简而言之，就是回溯问题，理解为 选择

比如说 第一步选择什么，然后跳到下一步继续选择，一直到终点（没有办法选择的时候）

针对于此，有时候我们的选择需要记录路径，在记录路径时带上我们需要的值，在循环结束后恢复原状

```ja
dfs(,,cur + ..., ) 
dfs(List<Integer> list)
```

这两种写法的话， 第一种不需要恢复现场，第二种需要，

理由很简单， 第一种返回的时候cur的值没变化， 而第二种返回的时候cur的值变化了

So the most important template for thinking:

```java
public void dfs() {
	if (.....) //结束条件 {
		//做一些处理
	}

	for (....) {
		//做出选择
		dfs() // 跳转到下一步的选择
		// 恢复现场
	}
}
```

我们在这其中要考虑的几个问题：

##### 1 不同写法是否要恢复原状

##### 2 每一次做出的选择是否合理 要判断

##### 3 单纯记录所有路径还是只要一个成功的完整路径，如果只要一个的话 需要考虑返回值（true）告诉后面的尝试 不需要了 （return 就是宣告在这一个位置的尝试结束）

##### 4 去重问题

```java
if (i > 0 && nums[i] == nums[i-1] && i > startIdx )
```

什么意思呢？ i > startIdx 说明在前一个选择的尝试已经结束，如果有恢复现场的话，记录在路径的前一个点会被弹出，你又加入了一个一摸一样的点，说明重复了刚才尝试的过程

#### Questions

##### 17 电话号码

需要1，2没要求，3不满足，4不需要去重

##### 22 括号问题

3不满足，所有路径

##### 78 Subsets + 90 Subsets

过程中 take a snapshot

##### 37 sudoku solver 51 N-queens

两题的思路非常像

##### 314 Vertical Order Tranversal (放在树的位置更合适)

树的遍历 找各种可能的情况，并且记录点 对应的pos 加入某个点

##### 465 做交易的题目

每一步选择和谁做交易，然后解决这一位的债务问题，跳转到下一位（不是做交易的那位）

#### 岛屿问题

-> 最简单的理解就是水漫金山->用水去不断的淹

-> 漫一片面积和求路径不是一个概念，这个一定要注意

-> visited 不需要恢复现场

##### 求岛屿的个数 -> 遍历每个岛屿，遍历完后加加

##### 求岛屿的面积 可以用分治法，也可以水漫金山，在每一步中求面积

#### Question

##### 200 Number of islands 非常经典

#### 分治法

分治法 总而言之 分问题的答案如何变成总问题的答案，这种想法很经典


#### Question
